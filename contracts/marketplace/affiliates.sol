// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

// The contract supports rank progression based on the number of direct referrals 
// and the sales volume generated by each referrer. 

// The `RankCriteria` struct is used to define the criteria for each rank, and the `rankCriterias` 
// array stores these structs.

// The contract has been updated to include the following new functions:

// 1. `updateSalesVolume(address referrer, uint256 amount)` - Updates the sales volume for a referrer.
// 2. `checkEligibilityForRankUp(address referrer)` - Checks if a referrer is eligible for a rank up based on the rank criteria.
// 3. `rankUp(address referrer)` - Performs a rank up for a referrer if they are eligible.

// Additionally, the `handleAffiliateProgram` function has been updated to update the sales volume for each 
// referrer in the hierarchy when processing rewards.

/// @custom:security-contact security@boomslag.com
contract Affiliates is AccessControl {
    // Safemath to avoid overflows
    using SafeMath for uint256;
    
    // Define a constant role for the booth role
    bytes32 public constant BOOTH_ROLE = keccak256("BOOTH_ROLE");
    // Define a constant role for the affiliates role
    bytes32 public constant AFFILIATE_ROLE = keccak256("AFFILIATE_ROLE");
    
    struct RankCriteria {
        uint256 requiredDirectReferrals;
        uint256 requiredSalesVolume;
    }
    
    // The percentage of the reward to be given to referrers at each level and rank (in basis points, e.g., 1000 = 10%)
    uint256[][] public referralRewardBasisPoints;
    // The mapping to store referrer addresses
    mapping(address => address) public referrers;
    // The mapping to store the rank of each referrer
    mapping(address => uint256) public referrerRanks;
    // The mapping to store the number of direct referrals for each referrer
    mapping(address => uint256) public directReferrals;
    // The mapping to store the sales volume for each referrer
    mapping(address => uint256) public salesVolume;
    // The mapping to store RankCriteria structs defining the criteria for each rank
    mapping(uint256 => RankCriteria) public rankCriterias;
    // The total number of rank criterias
    uint256 public rankCriteriasCount;
    // The maximum depth of the MLM hierarchy
    uint256 public maxDepth;

    constructor(
        uint256[][] memory _referralRewardBasisPoints,
        RankCriteria[] memory _rankCriterias,
        uint256 _maxDepth
    ) {
        referralRewardBasisPoints = _referralRewardBasisPoints;

        for (uint256 i = 0; i < _rankCriterias.length; i++) {
            rankCriterias[i] = _rankCriterias[i];
        }
        rankCriteriasCount = _rankCriterias.length;

        maxDepth = _maxDepth;

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(BOOTH_ROLE, msg.sender);
    }
    
    event ReferralRewardUpdated(uint256 level, uint256 rank, uint256 newRewardBasisPoints);
    event RankUp(address indexed referrer, uint256 newRank);
    event DirectReferralAdded(address indexed referrer, address indexed referral);
    event SalesVolumeUpdated(address indexed referrer, uint256 newSalesVolume);
    
    // Function to set Rewards for Ranks
    function setReferralReward(uint256 level, uint256 rank, uint256 newRewardBasisPoints) public onlyRole(BOOTH_ROLE) {
        referralRewardBasisPoints[level][rank] = newRewardBasisPoints;
        emit ReferralRewardUpdated(level, rank, newRewardBasisPoints);
    }
    // Function to set Referrer in the mapping
    function setReferrer(address guy, address referrer) external onlyBoothOrAffiliate {
        referrers[guy] = referrer;
        directReferrals[referrer]++;
        emit DirectReferralAdded(referrer, guy);
    }
    // Function to know who referred a user
    function getReferrer(address guy) external view returns (address) {
        return referrers[guy];
    }
    // Function to set the rank of a user
    function setReferrerRank(address referrer, uint256 rank) external onlyRole(BOOTH_ROLE) {
        referrerRanks[referrer] = rank;
    }
    // Function to get someones rank
    function getReferrerRank(address guy) public view returns (uint256) {
        uint256 currentRank = referrerRanks[guy];
        return currentRank;
    }
    // Function to set the hierarchy of the MLM. A bigger number might crash the system because of gas fees.
    function setMaxDepth(uint256 newMaxDepth) public onlyRole(BOOTH_ROLE) {
        maxDepth = newMaxDepth;
    }
    // Function to update how much a referrer has sold
    function updateSalesVolume(address referrer, uint256 amount) external onlyRole(BOOTH_ROLE) {
        salesVolume[referrer] += amount;
        emit SalesVolumeUpdated(referrer, salesVolume[referrer]);
    }
    // Function to get how deep the referral chain goes for a user
    function getReferralDepth(address guy) public view returns (uint256) {
        uint256 depth = 0;
        address currentReferrer = referrers[guy];

        while (currentReferrer != address(0) && depth < maxDepth) {
            depth++;
            currentReferrer = referrers[currentReferrer];
        }

        return depth;
    }
    // Function to check if user qualifies for a rank up
    function checkEligibilityForRankUp(address referrer) public view returns (bool) {
        uint256 currentRank = referrerRanks[referrer];
        if (currentRank >= rankCriteriasCount - 1) {
            // Already at the highest rank
            return false;
        }
        RankCriteria memory nextRankCriteria = rankCriterias[currentRank + 1];
        return directReferrals[referrer] >= nextRankCriteria.requiredDirectReferrals && salesVolume[referrer] >= nextRankCriteria.requiredSalesVolume;
    }
    // Function to rank user up to the next level
    function rankUp(address referrer) external onlyRole(BOOTH_ROLE) {
        require(checkEligibilityForRankUp(referrer), "Not eligible for rank up");
        uint256 newRank = referrerRanks[referrer] + 1;
        referrerRanks[referrer] = newRank;
        emit RankUp(referrer, newRank);
    }
    // Function to calculate rewards for an affiliate
    function calculateReward(address buyer, uint256 depth) public view returns (uint256) {
        // Get the referrer at the specified depth
        address referrerAtDepth = buyer;
        for (uint256 i = 0; i <= depth; i++) {
            referrerAtDepth = referrers[referrerAtDepth];
        }

        // Calculate the referral reward for the referrer at the specified depth
        uint256 referrerRank = referrerRanks[referrerAtDepth];
        uint256 purchasePrice = 1000; // Use a fixed value or pass it as an argument
        uint256 referralReward = (purchasePrice * referralRewardBasisPoints[depth][referrerRank]) / 10000;

        return referralReward;
    }
    // Function to pay affiliate commissions
    function handleAffiliateProgram(address buyer, uint256 paidValue) external payable onlyRole(BOOTH_ROLE) returns (uint256) {
        address currentReferrer = referrers[buyer];
        uint256 currentDepth = 0;

        uint256 remainingRewards = msg.value; // Use the ether sent with the transaction for referral rewards

        while (currentReferrer != address(0) && currentDepth < maxDepth) {
            uint256 referrerRank = referrerRanks[currentReferrer];
            uint256 referralReward = paidValue.mul(referralRewardBasisPoints[currentDepth][referrerRank]).div(10000);
            payable(currentReferrer).transfer(referralReward);
            remainingRewards -= referralReward;

            // Update sales volume
            salesVolume[currentReferrer] = salesVolume[currentReferrer].add(paidValue);
            emit SalesVolumeUpdated(currentReferrer, salesVolume[currentReferrer]);
            // Update referral chain
            currentReferrer = referrers[currentReferrer];
            currentDepth++;
        }

        return remainingRewards;
    }
    // Modifier to only allow using a method based on access control rules
    modifier onlyBoothOrAffiliate() {
        require(hasRole(BOOTH_ROLE, msg.sender) || hasRole(AFFILIATE_ROLE, msg.sender), "Caller is not a booth or an affiliate");
        _;
    }
}