// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/AccessControl.sol";

import "./affiliates.sol";
import "./types.sol";

contract AffiliateUtils is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    Affiliates public affiliatesContract;
    uint256 public maxPageSize = 100;

    constructor(Affiliates _affiliatesContract) {
        affiliatesContract = _affiliatesContract;
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    /**
     * @notice Sets the maximum page size for paginated queries.
     * @param _maxPageSize The new maximum page size to be set.
     * @dev Only callable by users with the ADMIN_ROLE.
     */
    function setMaxPageSize(uint256 _maxPageSize) public onlyRole(ADMIN_ROLE) {
        maxPageSize = _maxPageSize;
    }

    /**
     * @notice Assigns the Affiliates contract to interact with.
     * @param _affiliatesContract The address of the Affiliates contract.
     * @dev Only callable by users with the ADMIN_ROLE.
     */
    function setAffiliatesContract(Affiliates _affiliatesContract) public onlyRole(ADMIN_ROLE) {
        affiliatesContract = _affiliatesContract;
    }

    /* 
    /////////////////////////////
    Utility Functions
    /////////////////////////////

        Include utility functions like getter methods.
    */ 


    /**
     * @notice Retrieves comprehensive affiliate information.
     * @param affiliateAddress The address of the affiliate.
     * @return referrer The general referrer of the affiliate.
     * @return rank The rank of the affiliate.
     * @return directReferrals The number of direct referrals made by the affiliate.
     * @return salesVolume The total sales volume generated by the affiliate.
     * @dev Pulls data from the Affiliates contract.
     */
    function getAffiliateInformation(address affiliateAddress) 
        public 
        view 
        returns (
            address referrer, 
            uint256 rank, 
            uint256 directReferrals, 
            uint256 salesVolume
        ) 
    {
        referrer = affiliatesContract.getAffiliateReferrer(affiliateAddress);
        rank = affiliatesContract.getAffiliateRank(affiliateAddress);
        directReferrals = affiliatesContract.getAffiliateDirectReferrals(affiliateAddress);
        salesVolume = affiliatesContract.getAffiliateSalesVolume(affiliateAddress);
    }

    /**
     * @notice Retrieves detailed affiliate information specific to a particular NFT.
     * @param tokenId The ID of the NFT.
     * @param affiliateAddress The address of the affiliate.
     * @return isAffiliated Indicates if the affiliate is enrolled for this NFT.
     * @return referrer The referrer for this specific NFT.
     * @return level The network depth or level of the affiliate in the referral hierarchy for this NFT.
     * @return totalRewards The total rewards earned by the affiliate for this NFT.
     * @return pendingRewards The pending rewards for the affiliate for this NFT.
     * @return referredUsers The list of users referred by this affiliate for this NFT.
     * @dev Pulls data from the Affiliates contract for NFT-specific information.
     */
    function getNFTAffiliateInformation(uint256 tokenId, address affiliateAddress) 
        public 
        view 
        returns (
            bool isAffiliated,
            address referrer,
            uint256 level,
            uint256 totalRewards,
            uint256 pendingRewards,
            address[] memory referredUsers
        ) 
    {
        // Access the affiliate's NFT data from the Affiliates contract
        SharedTypes.AffiliateNFTData memory nftAffiliateData = affiliatesContract.getAffiliateNFTData(tokenId, affiliateAddress);

        // Return the relevant information
        return (
            nftAffiliateData.isAffiliated,
            nftAffiliateData.referrer,
            nftAffiliateData.networkDepth,
            nftAffiliateData.totalRewards,
            nftAffiliateData.pendingRewards,
            nftAffiliateData.referredUsers
        );
    }

    /**
     * @notice Retrieves a list of affiliate addresses for a given page and page size.
     * @param page The page number for pagination.
     * @param pageSize The number of results per page.
     * @return results An array of affiliate addresses for the specified page.
     * @return count The total number of affiliates.
     * @dev This function provides a paginated view of all affiliates. It assumes the existence of a function in the Affiliates contract to fetch the total number of affiliates.
     */
    function getAffiliates(uint256 page, uint256 pageSize) 
        public 
        view 
        returns (
            address[] memory results, 
            uint256 count
        ) 
    {
        count = affiliatesContract.getTotalAffiliates(); // Assuming this function exists
        uint256 startIndex = (page - 1) * pageSize;
        require(startIndex < count, "Start index out of range");

        if (pageSize > maxPageSize) {
            pageSize = maxPageSize;
        }

        uint256 endIndex = startIndex + pageSize > count ? count : startIndex + pageSize;
        results = new address[](endIndex - startIndex);

        for (uint256 i = startIndex; i < endIndex; i++) {
            results[i - startIndex] = affiliatesContract.getAffiliateAtIndex(i); // Assuming this function exists
        }

        return (results, count);
    }

    /**
     * @notice Retrieves all rank criteria defined in the Affiliates contract.
     * @return criterias An array of RankCriteria, detailing the requirements for each rank.
     * @dev This function fetches the complete list of rank criteria, including required direct referrals and sales volume for each rank.
     */
    function getAllRankCriterias() 
        public view 
        returns (SharedTypes.RankCriteria[] memory
    ) 
    {
        uint256 count = affiliatesContract.rankCriteriasCount();
        SharedTypes.RankCriteria[] memory criterias = new SharedTypes.RankCriteria[](count);

        for (uint256 i = 0; i < count; i++) {
            criterias[i] = affiliatesContract.getRankCriteria(i);
        }

        return criterias;
    }

    /**
     * @notice Retrieves a paginated list of NFT-specific affiliate data for affiliates referred by a specific referrer.
     * @param tokenId The token ID for which to fetch affiliate data.
     * @param rootAffiliate The root affiliate (referrer) whose referrals are to be fetched.
     * @param page The page number for pagination.
     * @param pageSize The number of results per page.
     * @return paginatedAffiliates An array of AffiliateNFTData, representing the NFT-specific data of affiliates referred by the root affiliate.
     * @return totalReferred The total number of affiliates referred by the root affiliate.
     * @dev This function provides a paginated view of NFT-specific affiliate data for a given referrer.
     */
    function getNftAffiliatesForReferrer(uint256 tokenId, address rootAffiliate, uint256 page, uint256 pageSize) 
        public 
        view 
        returns (SharedTypes.AffiliateNFTData[] memory, uint256) 
    {
        SharedTypes.AffiliateNFTData memory rootAffiliateData = affiliatesContract.getAffiliateNFTData(tokenId, rootAffiliate);
        address[] memory referredUsers = rootAffiliateData.referredUsers;

        uint256 totalReferred = referredUsers.length;
        uint256 startIndex = (page - 1) * pageSize;
        require(startIndex < totalReferred, "Start index out of range");

        if (pageSize > maxPageSize) {
            pageSize = maxPageSize;
        }

        uint256 endIndex = startIndex + pageSize > totalReferred ? totalReferred : startIndex + pageSize;
        SharedTypes.AffiliateNFTData[] memory paginatedAffiliates = new SharedTypes.AffiliateNFTData[](endIndex - startIndex);

        for (uint256 i = startIndex; i < endIndex; i++) {
            SharedTypes.AffiliateNFTData memory affiliateData = affiliatesContract.getAffiliateNFTData(tokenId, referredUsers[i]);
            paginatedAffiliates[i - startIndex] = affiliateData;
        }

        return (paginatedAffiliates, totalReferred);
    }

    /**
     * @notice Retrieves the referral chain for a specific affiliate in the context of a specific NFT.
     * @param tokenId The token ID related to the affiliate data.
     * @param affiliateAddress The address of the affiliate whose referral chain is to be fetched.
     * @return referralChain An array of addresses representing the referral chain of the affiliate for the specified NFT.
     * @dev This function returns the direct referrals made by an affiliate for a specific NFT.
     */
    function getNFTAffiliateReferralsChain(uint256 tokenId, address affiliateAddress) 
        public 
        view 
        returns (address[] memory referralChain) 
    {
        // Get the AffiliateData for the given affiliateAddress

        // Get the AffiliateNFTData for the given tokenId
        SharedTypes.AffiliateNFTData memory nftAffiliateData = affiliatesContract.getAffiliateNFTData(tokenId, affiliateAddress);

        // Return the referredUsers array from the NFT data
        return nftAffiliateData.referredUsers;
    }
}