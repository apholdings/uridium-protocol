// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import './types.sol';
import "../tickets/registry.sol";

/*
    The contract supports rank progression based on the number of direct referrals 
    and the sales volume generated by each referrer.

    The `RankCriteria` struct is used to define the criteria for each rank, and the `rankCriterias` 
    array stores these structs.

    The contract has been updated to include the following new functions:
    1. `updateSalesVolume(address referrer, uint256 amount)` - Updates the sales volume for a referrer.
    2. `checkEligibilityForRankUp(address referrer)` - Checks if a referrer is eligible for a rank up based on the rank criteria.
    3. `rankUp(address referrer)` - Performs a rank up for a referrer if they are eligible.
    
    Additionally, the `handleAffiliateProgram` function has been updated to update the sales volume for each 
    referrer in the hierarchy when processing rewards.
 */

/// @custom:security-contact security@boomslag.com
contract Affiliates is AccessControl {
    using SafeMath for uint256;

    /* 
    /////////////////////////////////
    1. Role Declarations 
    /////////////////////////////////

      - Define a constant role for the booth role
      - Define a constant role for the affiliates role

    */ 

    bytes32 public constant BOOTH_ROLE = keccak256("BOOTH_ROLE");
    
    /* 
    /////////////////////////////
    2. Structs and State Variables
    /////////////////////////////

        - referralRewardBasisPoints: The percentage of the reward to be given to referrers at each level and rank (in basis points, e.g., 1000 = 10%)
        - referrers: The mapping to store referrer addresses
        - referrerRanks: The mapping to store the rank of each referrer
        - directReferrals: The mapping to store the number of direct referrals for each referrer
        - salesVolume: The mapping to store the sales volume for each referrer
        - rankCriterias: The mapping to store RankCriteria structs defining the criteria for each rank
        - rankCriteriasCount: The total number of rank criterias
        - maxDepth: The maximum depth of the MLM hierarchy
        - affiliates: Array to store all affiliate addresses
        - nftAffiliates: Map each NFT token ID to a mapping of addresses to their affiliate data
        - nftAffiliateCounts: 
        - nftReferralRewards: 
    */ 

    TicketRegistry private ticketRegistry;
    uint256 public maxDepth;
    uint256[][] public referralRewardBasisPoints;
    uint256 public rankCriteriasCount;
    mapping(uint256 => SharedTypes.RankCriteria) public rankCriterias;
    mapping(address => SharedTypes.AffiliateData) public affiliates;
    mapping(uint256 => uint256) public nftAffiliateCounts;
    uint256 public affiliatesCount;
    address[] public affiliateAddresses;

    /* 
    /////////////////////////////
    3. Constructor and events
    /////////////////////////////

        The constructor initializes the contract's state.
      
        With this structure, affiliates are incentivized to improve their rank and work on their direct
        referrals as they receive higher rewards for higher ranks and closer relationships.
        At the same time, the maximum reward an affiliate can get from a single sale is capped at 25 %,
        ensuring a balance in the reward distribution.
        Level 1: Bronze 8%, Silver 10%, Gold 12%, Platinum 14%, Diamond 16%
        Level 2: Bronze 6%, Silver 8%,  Gold 10%, Platinum 12%, Diamond 14%
        Level 3: Bronze 4%, Silver 6%,  Gold 8%,  Platinum 10%, Diamond 12%
        Level 4: Bronze 2%, Silver 4%,  Gold 6%,  Platinum 8%,  Diamond 10%
        Level 5: Bronze 1%, Silver 2%,  Gold 4%,  Platinum 6%,  Diamond 8%
        
        // Define the rewrd bsis points array
        const referralRewardBasisPointsArray = [
            [1000, 1100, 1200, 1300, 1400],  Level 1: Bronze 10%, Silver 11%, Gold 12%, Platinum 13%, Diamond 14%
            [700,  850,  1000, 1150, 1300],  Level 2: Increase by a factor that reduces the gap slightly but still provides incentive for higher ranks
            [500,  650,  800,  950,  1100],  Level 3: Same as above, continue reducing the gap
            [300,  450,  600,  750,  900],   Level 4: Continue the trend
            [150,  300,  450,  600,  750]    Level 5: By this level, the difference between ranks narrows as the depth increases
        ];

        // Define the rank criteria
        const rankCriteriasArray = [
            {requiredDirectReferrals: 5, requiredSalesVolume: ethers.utils.parseEther("1")},
            {requiredDirectReferrals: 10, requiredSalesVolume: ethers.utils.parseEther("5")},
            {requiredDirectReferrals: 20, requiredSalesVolume: ethers.utils.parseEther("10")},
            {requiredDirectReferrals: 50, requiredSalesVolume: ethers.utils.parseEther("20")},
            {requiredDirectReferrals: 100, requiredSalesVolume: ethers.utils.parseEther("50")}
        ];

        maxDepth is the number of referrers an affiliate can have in their chain
    */ 

    // Constructor
    constructor(uint256[][] memory _referralRewardBasisPoints, SharedTypes.RankCriteria[] memory _rankCriterias, uint256 _maxDepth, address _ticketRegistryAddress) {
        referralRewardBasisPoints = _referralRewardBasisPoints;
        for (uint256 i = 0; i < _rankCriterias.length; i++) {
            rankCriterias[i] = _rankCriterias[i];
        }
        rankCriteriasCount = _rankCriterias.length;
        maxDepth = _maxDepth;
        ticketRegistry = TicketRegistry(_ticketRegistryAddress);
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }
    
    event AffiliateEnrolledForNFT(uint256 indexed tokenId, address indexed affiliateAddress, address referrerAddress);
    event SalesVolumeUpdated(address indexed referrer, uint256 newSalesVolume);
    event RankUp(address indexed referrer, uint256 newRank);
    event ReferralRewardUpdated(uint256 level, uint256 rank, uint256 reward);
    event ReferrerRankUpdated(address indexed referrer, uint256 rank);
    event RankCriteriaUpdated(uint256 indexed rank, SharedTypes.RankCriteria newCriteria);

    /* 
    /////////////////////////////
    4. Role-Based Functionality
    /////////////////////////////

      Group functions by the roles that can call them. 
      For example, all functions that require BOOTH_ROLE should be together.
    */ 

    /**
     * @notice Updates the maximum depth of the affiliate referral hierarchy.
     * @param newMaxDepth The new maximum depth to set.
     */
    function setMaxDepth(uint256 newMaxDepth) public onlyRole(BOOTH_ROLE) {
        maxDepth = newMaxDepth;
    }

    /**
     * @notice Modifier to ensure an affiliate is not already enrolled for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param affiliateAddress The address of the affiliate.
     */
    modifier notAlreadyEnrolled(uint256 tokenId, address affiliateAddress) {
        require(!affiliates[affiliateAddress].nftAffiliations[tokenId].isAffiliated, "Already an affiliate for this NFT");
        _;
    }

    /**
     * @notice Enrolls the initial affiliate for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param sellerAddress The address of the seller to be enrolled as an affiliate.
     */
    function enrollInitialAffiliateForNFT(uint256 tokenId, address sellerAddress) public 
        onlyRole(BOOTH_ROLE) 
        onlyRegisteredToken(tokenId) 
        notAlreadyEnrolled(tokenId, sellerAddress) 
    {
        // Enrolling seller as their own referrer for this NFT
        affiliates[sellerAddress].nftAffiliations[tokenId] = SharedTypes.AffiliateNFTData({
            isAffiliated: true,
            referrer: sellerAddress,
            networkDepth: 0,
            totalRewards: 0,
            pendingRewards: 0,
            referredUsers: new address[](0)
        });

        // Updating affiliate counts and addresses
        nftAffiliateCounts[tokenId]++;
        affiliatesCount++;
        affiliateAddresses.push(sellerAddress);
        emit AffiliateEnrolledForNFT(tokenId, sellerAddress, sellerAddress);
    }

    /**
     * @notice Enrolls an affiliate for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param affiliateAddress The address of the affiliate to enroll.
     * @param referrerAddress The address of the affiliate's referrer.
     */
    function enrollAffiliateForNFT(uint256 tokenId, address affiliateAddress, address referrerAddress) public 
        onlyRole(BOOTH_ROLE) 
        onlyRegisteredToken(tokenId) 
        notAlreadyEnrolled(tokenId, affiliateAddress) 
        isReferrerAffiliate(tokenId, referrerAddress) 
    {
        // Initializing general affiliate data for new affiliates
        SharedTypes.AffiliateData storage affiliate = affiliates[affiliateAddress];
        if (affiliate.generalReferrer == address(0)) {
            affiliate.generalReferrer = referrerAddress;
            affiliate.rank = 0;
            affiliate.directReferrals = 0;
            affiliate.salesVolume = 0;
        }

        // Calculating new affiliate level based on referrer's level
        uint256 referrerLevel = affiliates[referrerAddress].nftAffiliations[tokenId].networkDepth;
        uint256 newLevel = referrerLevel + 1;

        // Handling max depth limit
        if (newLevel >= maxDepth) {
            newLevel = 0;
            referrerAddress = referrerAddress;
        }

        // Enrolling affiliate and updating relevant data
        affiliate.nftAffiliations[tokenId] = SharedTypes.AffiliateNFTData({
            isAffiliated: true,
            referrer: referrerAddress,
            networkDepth: newLevel,
            totalRewards: 0,
            pendingRewards: 0,
            referredUsers: new address[](0)
        });
        affiliates[referrerAddress].nftAffiliations[tokenId].referredUsers.push(affiliateAddress);
        affiliates[referrerAddress].directReferrals = affiliates[referrerAddress].directReferrals.add(1);

        nftAffiliateCounts[tokenId]++;
        affiliatesCount++;
        affiliateAddresses.push(affiliateAddress);
        emit AffiliateEnrolledForNFT(tokenId, affiliateAddress, referrerAddress);
    }

    /**
     * @notice Checks if an affiliate is eligible for a rank upgrade.
     * @param affiliateAddress The address of the affiliate.
     * @return eligible Boolean indicating if the affiliate is eligible for a rank up.
     * @return currentRank The current rank of the affiliate.
     * @return requiredDirectReferrals The required direct referrals for the next rank.
     * @return requiredSalesVolume The required sales volume for the next rank.
     */
    function checkEligibilityForRankUp(address affiliateAddress) public view returns (bool eligible, uint256 currentRank, uint256 requiredDirectReferrals, uint256 requiredSalesVolume) {
        SharedTypes.AffiliateData storage affiliate = affiliates[affiliateAddress];
        currentRank = affiliate.rank;

        // Handling the highest rank limit
        if (currentRank >= rankCriteriasCount - 1) {
            return (false, currentRank, 0, 0);
        }

        // Fetching next rank criteria
        SharedTypes.RankCriteria memory nextRankCriteria = rankCriterias[currentRank + 1];
        requiredDirectReferrals = nextRankCriteria.requiredDirectReferrals;
        requiredSalesVolume = nextRankCriteria.requiredSalesVolume;

        // Checking eligibility
        eligible = (affiliate.directReferrals >= requiredDirectReferrals) && (affiliate.salesVolume >= requiredSalesVolume);
        return (eligible, currentRank, requiredDirectReferrals, requiredSalesVolume);
    }

    /**
     * @notice Sets new referral reward basis points for a specific level and rank.
     * @param level The level for which to set the new reward basis points.
     * @param rank The rank for which to set the new reward basis points.
     * @param newRewardBasisPoints The new reward basis points to set.
     */
    function setReferralRewardBasisPoints(uint256 level, uint256 rank, uint256 newRewardBasisPoints) public onlyRole(BOOTH_ROLE) {
        referralRewardBasisPoints[level][rank] = newRewardBasisPoints;
        emit ReferralRewardUpdated(level, rank, newRewardBasisPoints);
    }

    /**
     * @notice Update the criteria for a specific rank.
     * @param rank The rank to update.
     * @param newCriteria The new criteria for the rank.
     */
    function setRankCriteria(uint256 rank, SharedTypes.RankCriteria memory newCriteria) public onlyRole(BOOTH_ROLE) {
        require(rank < rankCriteriasCount, "Invalid rank");
        rankCriterias[rank] = newCriteria;
        emit RankCriteriaUpdated(rank, newCriteria);
    }

    /**
     * @notice Set the rank of a referrer.
     * @param affiliateAddress The address of the referrer.
     * @param rank The new rank to be set.
     */
    function setReferrerRank(address affiliateAddress, uint256 rank, uint256 tokenId) external onlyRole(BOOTH_ROLE) onlyRegisteredToken(tokenId) {
        require(affiliateAddress != address(0), "Invalid referrer address");
        require(rank < rankCriteriasCount, "Invalid rank");
        require(affiliates[affiliateAddress].nftAffiliations[tokenId].isAffiliated, "Referrer not enrolled for NFT");
        SharedTypes.AffiliateData storage affiliate = affiliates[affiliateAddress];
        affiliate.rank = rank;
        emit ReferrerRankUpdated(affiliateAddress, rank);
    }
    
    /**
     * @notice Updates the sales volume for a specific affiliate.
     * @param affiliateAddress The address of the affiliate whose sales volume is to be updated.
     * @param amount The amount to add to the affiliate's sales volume.
     * @dev This function should only be called by roles with the BOOTH_ROLE permission.
     */
    function updateSalesVolume(address affiliateAddress, uint256 amount) external onlyRole(BOOTH_ROLE) {
        require(affiliates[affiliateAddress].generalReferrer != address(0), "Affiliate does not exist");
        SharedTypes.AffiliateData storage affiliate = affiliates[affiliateAddress];
        affiliate.salesVolume = affiliates[affiliateAddress].salesVolume.add(amount);
        emit SalesVolumeUpdated(affiliateAddress, affiliates[affiliateAddress].salesVolume);
    }

    /**
     * @notice Increments the rank of an affiliate if they are eligible for a rank up.
     * @param affiliateAddress The address of the affiliate to rank up.
     * @dev This function checks the affiliate's eligibility before increasing their rank.
     *      Only callable by roles with the BOOTH_ROLE permission.
     */
    function rankUp(address affiliateAddress) external onlyRole(BOOTH_ROLE) {
        require(affiliates[affiliateAddress].generalReferrer != address(0), "Affiliate does not exist");
        (bool eligible, uint256 currentRank, , ) = checkEligibilityForRankUp(affiliateAddress);
        require(eligible, "Affiliate is not eligible for rank up");
        affiliates[affiliateAddress].rank = currentRank + 1;
        emit RankUp(affiliateAddress, currentRank + 1);
    }

    /**
     * @notice Handles the distribution of referral rewards for an NFT purchase.
     * @param tokenId The token ID of the NFT involved in the transaction.
     * @param buyer The address of the buyer.
     * @param referrer The address of the referrer.
     * @return remainingRewards The amount of funds remaining after distributing the rewards.
     * @dev Distributes referral rewards up the referral chain and updates sales volumes.
     *      Only callable by roles with the BOOTH_ROLE permission and for registered tokens.
     */
    function handleAffiliateProgram(uint256 tokenId, address buyer, address referrer) external payable onlyRole(BOOTH_ROLE) onlyRegisteredToken(tokenId) returns (uint256) {        
        if(!(affiliates[buyer].nftAffiliations[tokenId].isAffiliated)){
            enrollAffiliateForNFT(tokenId, buyer, referrer);
        }

        uint256 remainingRewards = msg.value;
        address currentAffiliate = referrer;
        uint256 currentDepth = 0;

        while (currentAffiliate != address(0) && currentDepth < maxDepth) {
            SharedTypes.AffiliateData storage affiliate = affiliates[currentAffiliate];
            SharedTypes.AffiliateNFTData storage nftAffiliateData = affiliate.nftAffiliations[tokenId];

            if (nftAffiliateData.isAffiliated) {
                uint256 referralReward = calculateReward(tokenId, currentAffiliate, msg.value);  // Using msg.value instead of remainingRewards

                payable(currentAffiliate).transfer(referralReward);
                remainingRewards -= referralReward;

                affiliate.salesVolume = affiliate.salesVolume.add(referralReward);
                nftAffiliateData.totalRewards = nftAffiliateData.totalRewards.add(referralReward);

                emit SalesVolumeUpdated(currentAffiliate, affiliate.salesVolume);
            }

            currentAffiliate = nftAffiliateData.referrer;
            currentDepth++;
        }
        return remainingRewards;
    }

    /**
     * @notice Calculates the referral reward for an affiliate based on the purchase price.
     * @param tokenId The token ID of the NFT involved in the transaction.
     * @param affiliate The address of the affiliate for whom the reward is being calculated.
     * @param purchasePrice The price of the NFT purchase.
     * @return referralReward The calculated referral reward for the affiliate.
     * @dev This calculation is based on the affiliate's rank and level within the referral system.
     *      Only callable for registered tokens.
     */
    function calculateReward(uint256 tokenId, address affiliate, uint256 purchasePrice) public view onlyRegisteredToken(tokenId) returns (uint256) {
        SharedTypes.AffiliateData storage affiliateData = affiliates[affiliate];
        SharedTypes.AffiliateNFTData storage nftAffiliateData = affiliateData.nftAffiliations[tokenId];

        require(nftAffiliateData.isAffiliated, "Affiliate not enrolled for this NFT");

        uint256 affiliateRank = affiliateData.rank;
        uint256 affiliateLevel = nftAffiliateData.networkDepth;

        uint256 referralRewardBasisPoint = referralRewardBasisPoints[affiliateLevel][affiliateRank];
        uint256 referralReward = (purchasePrice * referralRewardBasisPoint) / 10000;

        return referralReward;
    }

    /* 
    /////////////////////////////
    5. Helper Functions
    /////////////////////////////

      Include helper functions.
    */ 

    /**
     * @notice Retrieves the general referrer of an affiliate.
     * @param affiliate The address of the affiliate.
     * @return The address of the general referrer of the specified affiliate.
     */
    function getAffiliateReferrer(address affiliate) public view returns (address) {
        return affiliates[affiliate].generalReferrer;
    }

    /**
     * @notice Returns the number of direct referrals made by an affiliate.
     * @param affiliate The address of the affiliate.
     * @return The number of direct referrals made by the affiliate.
     */
    function getAffiliateDirectReferrals(address affiliate) public view returns (uint256) {
        return affiliates[affiliate].directReferrals;
    }

    /**
     * @notice Retrieves NFT-specific affiliate data.
     * @param tokenId The ID of the NFT.
     * @param affiliate The address of the affiliate.
     * @return NFT-specific affiliate data for the specified affiliate and NFT.
     */
    function getAffiliateNFTData(uint256 tokenId, address affiliate) public view onlyRegisteredToken(tokenId) returns (SharedTypes.AffiliateNFTData memory) {
        return affiliates[affiliate].nftAffiliations[tokenId];
    }

    /**
     * @notice Retrieves the rank of an affiliate.
     * @param affiliate The address of the affiliate.
     * @return The rank of the specified affiliate.
     */
    function getAffiliateRank(address affiliate) public view returns (uint256) {
        return affiliates[affiliate].rank;
    }

    /**
     * @notice Retrieves the total sales volume generated by an affiliate.
     * @param affiliate The address of the affiliate.
     * @return The total sales volume of the affiliate.
     */
    function getAffiliateSalesVolume(address affiliate) public view returns (uint256) {
        return affiliates[affiliate].salesVolume;
    }

    /**
     * @notice Retrieves the total rewards earned by an affiliate for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param affiliate The address of the affiliate.
     * @return Total rewards earned by the affiliate for the specified NFT.
     */
    function getAffiliateTotalRewards(uint256 tokenId, address affiliate) public view onlyRegisteredToken(tokenId) returns (uint256) {
        return affiliates[affiliate].nftAffiliations[tokenId].totalRewards;
    }

    /**
     * @notice Retrieves the list of users referred by an affiliate for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param affiliate The address of the affiliate.
     * @return List of users referred by the affiliate for the specified NFT.
     */
    function getNFTAffiliateReferredUsers(uint256 tokenId, address affiliate) public view onlyRegisteredToken(tokenId) returns (address[] memory) {
        return affiliates[affiliate].nftAffiliations[tokenId].referredUsers;
    }

    /**
     * @notice Retrieves the level of an affiliate for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param affiliateAddress The address of the affiliate.
     * @return The level of the affiliate for the specified NFT.
     */
    function getAffiliateLevel(uint256 tokenId, address affiliateAddress) public view onlyRegisteredToken(tokenId) returns (uint256) {
        // Ensure the affiliate is enrolled for the specified NFT
        require(affiliates[affiliateAddress].nftAffiliations[tokenId].isAffiliated, "Affiliate not enrolled for this NFT");

        // Return the level of the affiliate for the specific NFT
        return affiliates[affiliateAddress].nftAffiliations[tokenId].networkDepth;
    }

    /**
     * @notice Retrieves the referral reward basis points for all levels and ranks.
     * @return A two-dimensional array containing the referral reward basis points.
     */
    function getReferralRewardBasisPoints() public view returns (uint256[][] memory) {
        return referralRewardBasisPoints;
    }

    /**
     * @notice Retrieves the maximum depth allowed in the affiliate hierarchy.
     * @return The maximum depth of the affiliate hierarchy.
     */
    function getMaxDepth() public view returns (uint256) {
        return maxDepth;
    }

    /**
     * @notice Retrieves the referral reward basis points for a specific level and rank.
     * @param level The affiliate level.
     * @param rank The affiliate rank.
     * @return The referral reward basis points for the specified level and rank.
     */
    function getReferralRewardBasisPointsForLevelAndRank(uint256 level, uint256 rank) public view returns (uint256) {
        // Ensure the level and rank are within the bounds of the referralRewardBasisPoints array
        require(level < referralRewardBasisPoints.length, "Level out of range");
        require(rank < referralRewardBasisPoints[level].length, "Rank out of range");

        // Return the basis points for the given level and rank
        return referralRewardBasisPoints[level][rank];
    }
    
    /**
     * @notice Retrieves the criteria for a specific rank.
     * @param rank The rank number.
     * @return The criteria for the specified rank.
     */
    function getRankCriteria(uint256 rank) public view returns (SharedTypes.RankCriteria memory) {
        require(rank < rankCriteriasCount, "Rank number out of range");
        return rankCriterias[rank];
    }
    
    /**
     * @notice Retrieves the total number of affiliates.
     * @return The total number of affiliates.
     */
    function getTotalAffiliates() public view returns (uint256) {
        return affiliatesCount;
    }

    /**
     * @notice Retrieves the total number of affiliates for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @return The total number of affiliates for the specified NFT.
     */
    function getTotalNFTAffiliates(uint256 tokenId) public view onlyRegisteredToken(tokenId) returns (uint256) {
        return nftAffiliateCounts[tokenId];
    }
    
    /**
     * @notice Checks if a given address is an affiliate for a specific NFT.
     * @param tokenId The token ID of the NFT.
     * @param affiliateAddress The address to check.
     * @return True if the address is an affiliate for the NFT, otherwise false.
     */
    function isAffiliateForNFT(uint256 tokenId, address affiliateAddress) public view onlyRegisteredToken(tokenId) returns (bool) {
        // Access the affiliate's data for the specific NFT
        SharedTypes.AffiliateNFTData storage nftAffiliateData = affiliates[affiliateAddress].nftAffiliations[tokenId];

        // Check if the affiliate is affiliated with the specified NFT
        return nftAffiliateData.isAffiliated;
    }

    /**
     * @notice Retrieves the affiliate address at a given index in the affiliate list.
     * @param index The index in the affiliate list.
     * @return The address of the affiliate at the specified index.
     */
    function getAffiliateAtIndex(uint256 index) public view returns (address) {
        require(index < affiliateAddresses.length, "Index out of bounds");
        return affiliateAddresses[index];
    }

    /**
     * @notice Ensures that the specified token ID is registered.
     * @param _tokenId The token ID to check.
     */
    modifier onlyRegisteredToken(uint256 _tokenId) {
        require(ticketRegistry.isObjectRegistered(_tokenId), "Object is not registered");
        _;
    }

    /**
     * @notice Ensures that the specified referrer is an affiliate for the given token ID.
     * @param _tokenId The token ID.
     * @param referrer The address of the referrer.
     */
    modifier isReferrerAffiliate(uint256 _tokenId, address referrer) {
        require(affiliates[referrer].nftAffiliations[_tokenId].isAffiliated, "Referrer is not an affiliate for this tokenId");
        _;
    }
}