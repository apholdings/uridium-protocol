// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

/*
    The contract supports rank progression based on the number of direct referrals 
    and the sales volume generated by each referrer.

    The `RankCriteria` struct is used to define the criteria for each rank, and the `rankCriterias` 
    array stores these structs.

    The contract has been updated to include the following new functions:
    1. `updateSalesVolume(address referrer, uint256 amount)` - Updates the sales volume for a referrer.
    2. `checkEligibilityForRankUp(address referrer)` - Checks if a referrer is eligible for a rank up based on the rank criteria.
    3. `rankUp(address referrer)` - Performs a rank up for a referrer if they are eligible.
    
    Additionally, the `handleAffiliateProgram` function has been updated to update the sales volume for each 
    referrer in the hierarchy when processing rewards.
 */

/// @custom:security-contact security@boomslag.com
contract Affiliates is AccessControl {
    // Safemath to avoid overflows
    using SafeMath for uint256;

    /* /////////////////////////////////
      1. Contract and Role Declarations 
      - Define a constant role for the booth role
      - Define a constant role for the affiliates role
    */ /////////////////////////////////

    bytes32 public constant BOOTH_ROLE = keccak256("BOOTH_ROLE");
    bytes32 public constant AFFILIATE_ROLE = keccak256("AFFILIATE_ROLE");
    
    /* /////////////////////////////
      2. Structs and State Variables
    */ /////////////////////////////

    struct RankCriteria {
        uint256 requiredDirectReferrals;
        uint256 requiredSalesVolume;
    }
    
    // The percentage of the reward to be given to referrers at each level and rank (in basis points, e.g., 1000 = 10%)
    uint256[][] public referralRewardBasisPoints;
    // The mapping to store referrer addresses
    mapping(address => address) public referrers;
    // The mapping to store the rank of each referrer
    mapping(address => uint256) public referrerRanks;
    // The mapping to store the number of direct referrals for each referrer
    mapping(address => uint256) public directReferrals;
    // The mapping to store the sales volume for each referrer
    mapping(address => uint256) public salesVolume;
    // The mapping to store RankCriteria structs defining the criteria for each rank
    mapping(uint256 => RankCriteria) public rankCriterias;
    // The total number of rank criterias
    uint256 public rankCriteriasCount;
    // The maximum depth of the MLM hierarchy
    uint256 public maxDepth;

    /* /////////////////////////////
      3. Constructor and events
        The constructor initializes the contract's state.
      
        With this structure, affiliates are incentivized to improve their rank and work on their direct
        referrals as they receive higher rewards for higher ranks and closer relationships.
        At the same time, the maximum reward an affiliate can get from a single sale is capped at 25 %,
        ensuring a balance in the reward distribution.
        Level 1: Bronze 8%, Silver 10%, Gold 12%, Platinum 14%, Diamond 16%
        Level 2: Bronze 6%, Silver 8%,  Gold 10%, Platinum 12%, Diamond 14%
        Level 3: Bronze 4%, Silver 6%,  Gold 8%,  Platinum 10%, Diamond 12%
        Level 4: Bronze 2%, Silver 4%,  Gold 6%,  Platinum 8%,  Diamond 10%
        Level 5: Bronze 1%, Silver 2%,  Gold 4%,  Platinum 6%,  Diamond 8%
        
        // Define the rewrd bsis points array
        const referralRewardBasisPointsArray = [
            [1000, 1100, 1200, 1300, 1400],  Level 1: Bronze 10%, Silver 11%, Gold 12%, Platinum 13%, Diamond 14%
            [700,  850,  1000, 1150, 1300],  Level 2: Increase by a factor that reduces the gap slightly but still provides incentive for higher ranks
            [500,  650,  800,  950,  1100],  Level 3: Same as above, continue reducing the gap
            [300,  450,  600,  750,  900],   Level 4: Continue the trend
            [150,  300,  450,  600,  750]    Level 5: By this level, the difference between ranks narrows as the depth increases
        ];

        // Define the rank criteria
        const rankCriteriasArray = [
            {requiredDirectReferrals: 5, requiredSalesVolume: ethers.utils.parseEther("1")},
            {requiredDirectReferrals: 10, requiredSalesVolume: ethers.utils.parseEther("5")},
            {requiredDirectReferrals: 20, requiredSalesVolume: ethers.utils.parseEther("10")},
            {requiredDirectReferrals: 50, requiredSalesVolume: ethers.utils.parseEther("20")},
            {requiredDirectReferrals: 100, requiredSalesVolume: ethers.utils.parseEther("50")}
        ];

        maxDepth is the number of referrers an affiliate can have in their chain
    */ /////////////////////////////

    constructor(
        uint256[][] memory _referralRewardBasisPoints,
        RankCriteria[] memory _rankCriterias,
        uint256 _maxDepth
    ) {
        referralRewardBasisPoints = _referralRewardBasisPoints;

        for (uint256 i = 0; i < _rankCriterias.length; i++) {
            rankCriterias[i] = _rankCriterias[i];
        }
        rankCriteriasCount = _rankCriterias.length;

        maxDepth = _maxDepth;

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }
    
    event ReferralRewardUpdated(uint256 level, uint256 rank, uint256 newRewardBasisPoints);
    event RankUp(address indexed referrer, uint256 newRank);
    event DirectReferralAdded(address indexed referrer, address indexed referral);
    event SalesVolumeUpdated(address indexed referrer, uint256 newSalesVolume);


    /* /////////////////////////////
      4. Role-Based Functionality
      Group functions by the roles that can call them. 
      For example, all functions that require BOOTH_ROLE should be together.
    */ /////////////////////////////

    // Function to set Rewards for Ranks
    function setReferralReward(uint256 level, uint256 rank, uint256 newRewardBasisPoints) public onlyRole(BOOTH_ROLE) {
        referralRewardBasisPoints[level][rank] = newRewardBasisPoints;
        emit ReferralRewardUpdated(level, rank, newRewardBasisPoints);
    }
    // Function to set the rank of a user
    function setReferrerRank(address referrer, uint256 rank) external onlyRole(BOOTH_ROLE) {
        referrerRanks[referrer] = rank;
    }
    // Function to update how much a referrer has sold
    function updateSalesVolume(address referrer, uint256 amount) external onlyRole(BOOTH_ROLE) {
        salesVolume[referrer] += amount;
        emit SalesVolumeUpdated(referrer, salesVolume[referrer]);
    }
    // Function to set the hierarchy of the MLM. A bigger number might crash the system because of gas fees.
    function setMaxDepth(uint256 newMaxDepth) public onlyRole(BOOTH_ROLE) {
        maxDepth = newMaxDepth;
    }
    // Function to rank user up to the next level
    function rankUp(address referrer) external onlyRole(BOOTH_ROLE) {
        require(checkEligibilityForRankUp(referrer), "Not eligible for rank up");
        uint256 newRank = referrerRanks[referrer] + 1;
        referrerRanks[referrer] = newRank;
        emit RankUp(referrer, newRank);
    }
    // Function to pay affiliate commissions
    function handleAffiliateProgram(address buyer, uint256 paidValue) external payable onlyRole(BOOTH_ROLE) returns (uint256) {
        address currentReferrer = referrers[buyer];
        uint256 currentDepth = 0;

        uint256 remainingRewards = msg.value; // Use the ether sent with the transaction for referral rewards

        while (currentReferrer != address(0) && currentDepth < maxDepth) {
            uint256 referrerRank = referrerRanks[currentReferrer];
            uint256 referralReward = paidValue.mul(referralRewardBasisPoints[currentDepth][referrerRank]).div(10000);
            payable(currentReferrer).transfer(referralReward);
            remainingRewards -= referralReward;

            // Update sales volume
            salesVolume[currentReferrer] = salesVolume[currentReferrer].add(paidValue);
            emit SalesVolumeUpdated(currentReferrer, salesVolume[currentReferrer]);
            // Update referral chain
            currentReferrer = referrers[currentReferrer];
            currentDepth++;
        }

        return remainingRewards;
    }
    // Function to set Referrer in the mapping
    function setReferrer(address guy, address referrer) external onlyBoothOrAffiliate {
        referrers[guy] = referrer;
        directReferrals[referrer]++;
        emit DirectReferralAdded(referrer, guy);
    }

    /* /////////////////////////////
      5. Utility Functions and modifiers
      Include utility functions like getReferrer and getReferrerRank.
    */ /////////////////////////////

    // Function to know who referred a user
    function getReferrer(address guy) external view returns (address) {
        return referrers[guy];
    }
    // Function to get someones rank
    function getReferrerRank(address guy) public view returns (uint256) {
        uint256 currentRank = referrerRanks[guy];
        return currentRank;
    }
    // Function to get how deep the referral chain goes for a user
    function getReferralDepth(address guy) public view returns (uint256) {
        uint256 depth = 0;
        address currentReferrer = referrers[guy];

        while (currentReferrer != address(0) && depth < maxDepth) {
            depth++;
            currentReferrer = referrers[currentReferrer];
        }

        return depth;
    }
    // Function to check if user qualifies for a rank up
    function checkEligibilityForRankUp(address referrer) public view returns (bool) {
        uint256 currentRank = referrerRanks[referrer];
        if (currentRank >= rankCriteriasCount - 1) {
            // Already at the highest rank
            return false;
        }
        RankCriteria memory nextRankCriteria = rankCriterias[currentRank + 1];
        return directReferrals[referrer] >= nextRankCriteria.requiredDirectReferrals && salesVolume[referrer] >= nextRankCriteria.requiredSalesVolume;
    }
    // Function to calculate rewards for an affiliate
    function calculateReward(address buyer, uint256 depth) public view returns (uint256) {
        // Get the referrer at the specified depth
        address referrerAtDepth = buyer;
        for (uint256 i = 0; i <= depth; i++) {
            referrerAtDepth = referrers[referrerAtDepth];
        }

        // Calculate the referral reward for the referrer at the specified depth
        uint256 referrerRank = referrerRanks[referrerAtDepth];
        uint256 purchasePrice = 1000; // Use a fixed value or pass it as an argument
        uint256 referralReward = (purchasePrice * referralRewardBasisPoints[depth][referrerRank]) / 10000;

        return referralReward;
    }
    
    // Modifier to only allow using a method based on access control rules
    modifier onlyBoothOrAffiliate() {
        require(hasRole(BOOTH_ROLE, msg.sender) || hasRole(AFFILIATE_ROLE, msg.sender), "Caller is not a booth or an affiliate");
        _;
    }
}